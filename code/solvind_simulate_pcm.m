more off

%%%%%% Test c_p(T) generated by .cpp file %%%%%%%
% data = importdata('c_p.txt');
% plot(data(:,1), data(:,2)); hold on
% plot(data(:,1), data(:,3));
% return


% Set Simulation parameters
T_0 = 10.;
T_end = 200.;

L1 = 15;  % [mm]
L3 = 0.5;  % [mm]
N1 = 200;
N3 = 50;  % error if N3=0
 
lambda_Const = 23.;  % [mW/(mm*K)]
rho_Const = 8.9;     % [mg/mm^3]
c_p_Const = 0.41;    % [mJ/(mg*K)]

lambda_pcm = 0.96;   % [mW/(mm*K)]
rho_pcm = 0.8;       % [mg/mm^3]

heat_rate = 10.;     % [K/min]
heat_rate_s = heat_rate / 60; % [K/min] -> [K/s]

% c_p parametrization with NURBS
cntrl_pts_x = [0, 30, 60, 90, 120, 125, 130, 132., 135, 150, 160, 180];
cntrl_pts_y = [1., 1,  1.1, 1.15, 1.2, 5., 10, 1.5, 1.51, 1.52, 1.53, 1.55];
%cntrl_pts_y = [1., 1,  1.1, 1.15, 1.2, 1.5, 2., 1.5, 1.51, 1.52, 1.53, 1.55];
%cntrl_pts_y = 2. * ones(1, length(cntrl_pts_x));
num_cntrl_pts = length(cntrl_pts_x);


% compute analytical solution for T_ref
dt = 0.05 / heat_rate_s; % fct evaluation every 0.05K
t = 0:dt:1/heat_rate_s*(T_end - T_0);
n = 100;
a = lambda_Const / (c_p_Const * rho_Const);
T_ref = analytical_sol(L1,t,n,T_0, heat_rate_s, a); 


% some pre-calculations
N = N1+N3;
a_Const = lambda_Const/(rho_Const*c_p_Const);


solvind('importDynamicModelLib', '/home/argo/SOLVIND_SUITE/Packages/SOLVIND/Debug/TEST/MODELS/libdynModelDesc_heat1D_pcm.so');

% Create model with grid specified by L1, L3, N1 and N3.
% Afterwards create integrator and link integrator with model.
model = solvind('createDynamicModel', 'heat1D_pcm', ...
                sprintf('0 %2.2f %2.2f %d %d %d -', L1, L3, N1, N3, num_cntrl_pts));
int = solvind('createIntegrator', 'daesol2_sparse_withCorrIters');
solvind('setModel', int, model);

model_dims = solvind('getDims', model);
num_params = model_dims.np;

% options
solvind('setTapeStorageMode', int, 'values');
solvind('setPrintLevel', int, 0);
pL = solvind('getPrintLevel', int);

solvind('setRelTol', int, 1e-3);  
% abs. Differenz (der integrierten FUnktion) von 1e-2 zu 1e-3 weniger als ein Promille...
solvind('setMaxIntSteps', int, 2000);
solvind('setCorrectorAccuracyFactor', int, 1e-4);
solvind('setCorrectorAbsoluteAccuracy', int, 1e-10);

t_0 = 0.;
t_end = (T_end - T_0) / heat_rate_s;

solvind('setTimeHorizon', int, [t_0, t_end]);
ogrid = linspace(t_0, t_end, int32((T_end - T_0)*20. + 1));
% function evaluation every 0.05 K of T_oven, independend of heat_rate
solvind('setContOutputConfig', int, ogrid);
solvind('storeAdjSensAtGrid', int);

T_0_vec = T_0*ones(N,1);

p = [a_Const, lambda_pcm, rho_pcm, heat_rate, cntrl_pts_x, cntrl_pts_y]';

assert(num_params == length(p), ...
    'Number of paramters inconsistent in model and matlab code!');


initValues = [T_0_vec; p];
solvind('setInitVals', int, initValues);

retval = solvind('evaluate', int);

if retval == 0
	sol = solvind('getSolution', int);
	contsol = solvind('getContOutput', int);

	stats = solvind('getStats', int);
	timings = solvind('getTimings', int);
end



%plot(t, contsol(1, :)); hold on
%plot(t, contsol(N1, :)); 

% dT = T_ref' - contsol(N1,:);
% plot(T_ref, dT, 'DisplayName', num2str(heat_rate)); hold on


% compute first order forward sensitivities
fwdSensDir = [zeros(1,N+num_params); eye(N+num_params)];
solvind('setForwardTaylorCoefficients', int, N+num_params, 1, fwdSensDir);
retval = solvind('forwardSensSweep', int);
if retval == 0
	fwdSens = solvind('getFwdSens', int);
end


% compute first order adjoints
adjSensDir = eye(N);
solvind('setForwardTaylorCoefficients', int, []);
solvind('setAdjointTaylorCoefficients', int, N, 0, 1, adjSensDir);
retval = solvind('backwardSensSweep', int);
if retval == 0
	adjSens = solvind('getAdjSens', int);
	[gridT, gridAdj] = solvind('getAdjSensAtGrid', int);
end


fprintf('Deviation of fwd and adj 1st order derivatives: %e\n', ...
	norm(adjSens(2:end,:)' - fwdSens));

% tape = solvind('getTape', int, 0);


% free memory
solvind('reset');

