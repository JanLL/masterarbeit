more off

%%%%%%%%% Test c_p(T) generated by .cpp file %%%%%%%
% data = importdata('c_p.txt');
% plot(data(:,1), data(:,2)); hold on
% plot(data(:,1), data(:,3));
% return


% Set Simulation parameters
T_0 = 10.;
T_end = 200.;

L1 = 15;  % [mm]
L3 = 0.5;  % [mm]
N1 = 200;
N3 = 50;  % error if N3=0
 
lambda_Const = 23.;  % [mW/(mm*K)]
rho_Const = 8.9;     % [mg/mm^3]
c_p_Const = 0.41;    % [mJ/(mg*K)]

lambda_pcm = 0.96;   % [mW/(mm*K)]
rho_pcm = 0.8;       % [mg/mm^3]

heat_rate = 10.;     % [K/min]
heat_rate_s = heat_rate / 60; % [K/min] -> [K/s]

% c_p parametrization with Fraser-Suzuki-Peak
h  =  30.0;
r  =  30.0;
wr =  15.0;
sr =   0.3;
z  = 125.0;
b  =   2.0;

p_fraser_suzuki = [h, r, wr, sr, z, b];

%%%%%%%%%% Analytical solution for T_ref %%%%%%%%%%%%%%%%%%%%%%
dt = 0.05 / heat_rate_s; % fct evaluation every 0.05K
t = 0:dt:1/heat_rate_s*(T_end - T_0);
n = 100;
a = lambda_Const / (c_p_Const * rho_Const);
T_ref = analytical_sol(L1,t,n,T_0, heat_rate_s, a); 


% some pre-calculations
N = N1+N3;
a_Const = lambda_Const/(rho_Const*c_p_Const);


solvind('importDynamicModelLib', '/home/argo/SOLVIND_SUITE/Packages/SOLVIND/Debug/TEST/MODELS/libdynModelDesc_heat1D_pcm.so');

% Create model with grid specified by L1, L3, N1 and N3.
% Afterwards create integrator and link integrator with model.
model = solvind('createDynamicModel', 'heat1D_pcm', ...
                sprintf('0 %2.2f %2.2f %d %d -', L1, L3, N1, N3));
int = solvind('createIntegrator', 'daesol2_sparse_withCorrIters');
solvind('setModel', int, model);

model_dims = solvind('getDims', model);
num_params = model_dims.np;

% options
solvind('setTapeStorageMode', int, 'values');
solvind('setPrintLevel', int, 0);
pL = solvind('getPrintLevel', int);

solvind('setRelTol', int, 1e-4);  
% abs. Differenz (der integrierten FUnktion) von 1e-2 zu 1e-3 weniger als ein Promille...
solvind('setMaxIntSteps', int, 2000);
solvind('setCorrectorAccuracyFactor', int, 1e-4);
solvind('setCorrectorAbsoluteAccuracy', int, 1e-13);

t_0 = 0.;
t_end = (T_end - T_0) / heat_rate_s;

solvind('setTimeHorizon', int, [t_0, t_end]);
ogrid = linspace(t_0, t_end, int32((T_end - T_0)*20. + 1));
% function evaluation every 0.05 K of T_oven, independend of heat_rate
solvind('setContOutputConfig', int, ogrid);
solvind('storeAdjSensAtGrid', int);

T_0_vec = T_0*ones(N,1);

p = [a_Const, lambda_pcm, rho_pcm, heat_rate, p_fraser_suzuki]';

assert(num_params == length(p), ...
    'Number of paramters inconsistent in model and matlab code!');


initValues = [T_0_vec; p];
solvind('setInitVals', int, initValues);

fprintf('Start integration...\n');
retval = solvind('evaluate', int);

if retval == 0
	sol = solvind('getSolution', int);
	contsol = solvind('getContOutput', int);

	stats = solvind('getStats', int);
	timings = solvind('getTimings', int);
end



plot(T_ref, contsol(1, :)); hold on
plot(T_ref, contsol(N1, :)); 

% dT = T_ref' - contsol(N1,:);
% plot(T_ref, dT, 'DisplayName', num2str(heat_rate)); hold on


% compute first order forward sensitivities
fprintf('Computing forward sensitivities...\n')
fwdSensDir = [zeros(1,num_params); zeros(N, num_params); eye(num_params)];
solvind('setForwardTaylorCoefficients', int, num_params, 1, fwdSensDir);
retval = solvind('forwardSensSweep', int);
if retval == 0
	fwdSens = solvind('getFwdSens', int);
end



% % compute first order adjoints
% adjSensDir = eye(N);
% solvind('setForwardTaylorCoefficients', int, []);
% solvind('setAdjointTaylorCoefficients', int, N, 0, 1, adjSensDir);
% retval = solvind('backwardSensSweep', int);
% if retval == 0
% 	adjSens = solvind('getAdjSens', int);
% 	[gridT, gridAdj] = solvind('getAdjSensAtGrid', int);
% end


% fprintf('Deviation of fwd and adj 1st order derivatives: %e\n', ...
% 	norm(adjSens(2:end,:)' - fwdSens));



figure()
image(fwdSens(:,end-num_params+1+4:end-1), 'CDataMapping', 'scaled')
colorbar



















% tape = solvind('getTape', int, 0);


% free memory
solvind('reset');
clear solvind;

